Repo experimental pel projecte de veritat, contenint arxius necessaris i format adient
Modulo 6 --> pyproject.toml (tambien mirar requirements modulo 2) + invoke (usando tasks.py)
Modulo 2 --> requirements.txt (a partir pipreqs!!, pip list, pip freeze!!!)
Modulo 4 --> launch.json + archivos .py + folder data
Modulo 2 --> environment.yaml (a partir conda list)
Modulo 7 --> codi ben documentat (comments, docstrings) + ruff (para ser pep8 compliant, explica como configurar ruff en pyproject 
y diferentes reglas etc para styling) + mypy (typing: comprobar que tingui sentit)
Modulo 8 --> dvc (mirar tema contraseñas, permisos, arxiu config, valorar si crear service account, etc) + googlecloud (guardar data alli) + gdown (descarregar data de altres drives)
Modulo 9 --> Hacer que se pueda ejecutar "train" así tal cual en terminal e.g. (usando [project.scripts]
train = "my_project.train:main" en pyproject). Tambien se puede seguir usando python archivo.py o con el debugger
+ invoke (crear nuevas taks --> evitar mencionar docker python y acortar codigos)
Modulo 10 --> Docker (docker built: crear imagen + docker run: crear contenedor a partir imagen y train.dockerfile + docker cd/docker run -v: copiar archivos entre
contenedor y máquina)

Contenedor → host
docker cp experiment1:/models/model.pth ./models/model.pth
Host → contenedor
docker cp ./models/model.pth experiment1:/models/model.pth

BIDIRECCIONAL (SINCRONIZACION CONSTANTE)
docker run --name experiment1 -v "$(pwd)/models:/models" train:latest



- Faltara añadir en README (esquema) lo de .vscode --> launch.json
- Tambien poner en README.md como hay que ejecutar cada cosa (explicar invoke para train, opcion debugger, hay que estar en carpeta root del repo muy importante 
(ya sea para runear desde terminal, desde debugger o lo que sea)!!!!)
- Para invoke, recordar añadir tasks en proyecto para hacer mas facil ejecucion de modulos/ficheros etc (modulo 6 + 9)
- Recordar ir actualizando requirements.txt con pip freeze o pipreqs
- Siempre ejecutar pip install -e . desde el root para adquirir packages (carpeto con _init__.py vacio) y requirements
- La carpeta que contiene _init__.py quiere decir que los archivos son packages y cuyas funciones/classes son modulos. Entonces en nuestro caso hariamos:
from project_test.package (el nombre archivo) import module (nombre funcion, classe dentro de ese archivo)
- if __name__ == "__main__":
    typer.run(evaluate)
    Lo que hace esto es que ademas de definir funciones/modulos en ese archivo, al hacer python archivo.py tambien se ejecute la funcion, sino habria que crear otro
    archivo que hiciera referencia a este archivo y fuera un output
- Deberiamos añadir más rules en ruff (modulo 7)
- En gitignore, nse si deberiamos procurar que los archivos que se crean al ejecutar data.py y train.py, etc, deberian ser puestos alli